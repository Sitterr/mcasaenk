using Mcasaenk.Rendering;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO.Compression;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;
using Mcasaenk;
using static Utils2.AssetsUtils;
using System.Drawing.Imaging;

namespace Utils2 {
    public static class ColormapMaker {

        // must point to the unziped path
        public static void FromResourcePacks(string path, string[] resourcepacks, int f, double q = 1) {
            using var fstream = new FileStream(path, FileMode.Create);
            using var archive = new ZipArchive(fstream, ZipArchiveMode.Create);

            {
                var d = BlockStatesToModel(resourcepacks);
                var res = ModelsToMeanColor(resourcepacks, d, q);
                List<string> lines = new() { "// automatically generated by Utils.AssetsUtils.FromResourcePacks" };
                foreach(var r in res) {
                    string name = r.Key;
                    string color = r.Value;

                    lines.Add($"{name.simplifyminecraftname()};{color}");
                }

                createFileFromLines(archive, "__colormap__", lines.ToArray());
            }

            {
                Dictionary<string, (string name, string format, List<string> blocks, string color)> tints = new();
                TxtFormatReader.ReadStandartFormat(Resources.tintblocks, (group, parts) => {
                    string name = parts[0].Split('|')[Math.Clamp(0, f, parts[0].Split('|').Length - 1)];
                    if(tints.ContainsKey(name)) {
                        tints[name].blocks.AddRange(parts[2].Split(',').Select(x => x.Trim().minecraftname()).ToList());
                    } else {
                        tints[name] = (name, parts[1], parts[2].Split(',').Select(x => x.Trim()).ToList(), parts[3]);
                    }
                });

                foreach(var v in tints.Values) {
                    List<string> lines =
                    [
                        $"format={v.format}",
                        $"blocks={string.Join(" ", v.blocks.Select(b => b.simplifyminecraftname()))}",
                    ];
                    if(v.color != "") lines.Add($"color={v.color}");

                    createFileFromLines(archive, $"{v.name}.properties", lines.ToArray());
                }
            }

            {
                Bitmap grass_bmp = null, foliage_bmp = null;
                foreach(var packpath in resourcepacks.Reverse()) {
                    string grass_path = Path.Combine(packpath, "assets", "minecraft", "textures", "colormap", "grass.png");
                    if(grass_bmp == null && File.Exists(grass_path)) grass_bmp = new Bitmap(grass_path);

                    string foliage_path = Path.Combine(packpath, "assets", "minecraft", "textures", "colormap", "foliage.png");
                    if(foliage_bmp == null && File.Exists(foliage_path)) foliage_bmp = new Bitmap(foliage_path);
                }

                createFile(archive, "grass.png", ImageToByte2(grass_bmp));
                createFile(archive, "foliage.png", ImageToByte2(foliage_bmp));
            }








            Dictionary<string, string> BlockStatesToModel(string[] resourcepacks) {
                Dictionary<string, string> dict = new();
                foreach(var resourcepack in resourcepacks) {
                    foreach(var mnamespace in Directory.GetDirectories(Path.Combine(resourcepack, "assets"))) {
                        foreach(var file in Directory.GetFiles(Path.Combine(mnamespace, "blockstates"))) {
                            if(Path.GetExtension(file) != ".json") continue;
                            string name = new DirectoryInfo(mnamespace).Name + ":" + Path.GetFileNameWithoutExtension(file);
                            dict[name] = ReadModelFromBlockState(File.ReadAllText(file));
                        }
                    }
                }
                return dict;
            }
            string ReadModelFromBlockState(string filecontent) {
                try {
                    var jsonDocument = JsonDocument.Parse(filecontent);
                    var root = jsonDocument.RootElement;

                    string modelname = "";
                    if(root.TryGetProperty("variants", out var variants)) {
                        if(!variants.TryGetProperty("", out var variant)) {
                            variant = variants.EnumerateObject().First().Value;
                        }
                        modelname = variant.getObjectOrFirstElement("model").GetString();
                    } else if(root.TryGetProperty("multipart", out var multipart)) {
                        var firstEl = multipart.EnumerateArray().First();
                        modelname = firstEl.GetProperty("apply").getObjectOrFirstElement("model").GetString();
                    }

                    return toLocation(modelname, "models", "json");
                }
                catch {
                    return "";
                }
            }
            Dictionary<string, string> ModelsToMeanColor(string[] resourcepacks, Dictionary<string, string> blocksstatemodel, double q) {
                Dictionary<string, string> map = new();

                foreach(var resourcepack in resourcepacks.Reverse()) {
                    foreach(var blockmodel in blocksstatemodel) {
                        if(map.ContainsKey(blockmodel.Key)) continue;

                        string textureloc = GetTextureLocFromModel(resourcepack, blockmodel.Value);
                        foreach(var pack in resourcepacks.Reverse()) {
                            string color = ReadMeanColorOfTexture(pack, textureloc, q);
                            if(color != "") {
                                map[blockmodel.Key] = color;
                                break;
                            }
                        }
                    }
                }
                return map;
            }
            string GetTextureLocFromModel(string resource_pack, string modellocation) {
                if(Path.Exists(Path.Combine(resource_pack, modellocation)) == false) return "";

                JsonDocument jsonDocument;
                try {
                    jsonDocument = JsonDocument.Parse(File.ReadAllText(Path.Combine(resource_pack, modellocation)));
                }
                catch {
                    return "";
                }
                var root = jsonDocument.RootElement;

                string texturename = "";
                if(root.TryGetProperty("textures", out var texturesEl)) {
                    if(texturesEl.TryGetProperty("texture", out var textr)) {
                        texturename = textr.GetString();
                    } else {

                        foreach(var type in texturesEl.EnumerateObject()) {
                            if(type.Name == "top") {
                                texturename = type.Value.GetString();
                            }
                        }
                        if(texturename == "") texturename = texturesEl.EnumerateObject().First().Value.GetString();
                    }
                }
                if(texturename == "") return "";

                return toLocation(texturename, "textures", "png");
            }

            string ReadMeanColorOfTexture(string resource_pack, string textureloc, double q) {
                string texturePath = Path.Combine(resource_pack, textureloc);
                if(File.Exists(texturePath) == false) return "";


                var bitmap = new Bitmap(texturePath);
                int pixelCount = bitmap.Width * bitmap.Height;
                int r = 0, g = 0, b = 0;
                int numberOfTransparent = 0;
                for(int x = 0; x < bitmap.Width; x++) {
                    for(int y = 0; y < bitmap.Height; y++) {
                        var pixel = bitmap.GetPixel(x, y);

                        if(pixel.A == 0) numberOfTransparent++;
                        else {
                            r += pixel.R;
                            g += pixel.G;
                            b += pixel.B;
                        }
                    }
                }
                if(numberOfTransparent > q * pixelCount) {
                    return "";
                } else {
                    r /= (pixelCount - numberOfTransparent);
                    g /= (pixelCount - numberOfTransparent);
                    b /= (pixelCount - numberOfTransparent);
                }
                return ((byte)r).ToString("X2") + ((byte)g).ToString("X2") + ((byte)b).ToString("X2");
            }

            string toLocation(string name, string object_type, string suffix) {
                string mnamespace = "minecraft", path = name;
                if(name.Contains(":")) {
                    mnamespace = name.Split(':')[0];
                    path = path.Split(':')[1];
                }

                return $"assets/{mnamespace}/{object_type}/{path}.{suffix}";
            }
        }

        public static void FromJavaMap(string path, string resourcepack, Bitmap blockMap) {
            using var fstream = new FileStream(path, FileMode.Create);
            using var archive = new ZipArchive(fstream, ZipArchiveMode.Create);

            var map = ReadIngameMap(blockMap, GetVanillaBlockNames(resourcepack));

            createFileFromLines(archive, "__colormap__", map.Select(v => $"{v.Key.simplifyminecraftname()};{v.Value}").ToArray());
        }


        public static void FromBedrockMap(string path, string resourcepack, Bitmap blockMap, Bitmap[] biomeMaps) {
            using var fstream = new FileStream(path, FileMode.Create);
            using var archive = new ZipArchive(fstream, ZipArchiveMode.Create);

            var map = ReadIngameMap(blockMap, GetVanillaBlockNames(resourcepack));

            List<(string tint, string[] blocks)> tints = new();
            List<string> tintedBlocks = new();
            TxtFormatReader.ReadStandartFormat(Resources.tintblocks, (string group, string[] parts) => {
                string[] blocks = parts[2].Split(',').Select(v => v.Trim().minecraftname()).ToArray();
                tintedBlocks.AddRange(blocks);
                if(parts[1] == "vanilla_grass" || parts[1] == "vanilla_foliage" || parts[1] == "vanilla_water") {
                    tints.Add((parts[1].Split("_")[1], blocks));
                }
            });
            var biomes = Resources.javabiomes.Split("\r\n").ToArray();

            int plainsIndex = Array.IndexOf(biomes, "plains");

            if(biomeMaps.Length != Math.Ceiling((double)biomes.Length / 25)) throw new Exception("biomi");


            // https://minecraft.wiki/w/Plains
            Color BEDROCK_PLAINS_GRASS_TINT = ColorTranslator.FromHtml("#91BD59");
            Color BEDROCK_PLAINS_FOLIAGE_TINT = ColorTranslator.FromHtml("#77AB2F");


            Dictionary<string, (string tint, List<Color> colors)> colors = new();
            {
                foreach(var entry in ReadBiomeInGameMap()) {
                    if(colors.ContainsKey(entry.block) == false) {
                        colors[entry.block] = (entry.tint, new List<Color>());
                    }

                    colors[entry.block].colors.Add(entry.color);
                }
            }

            Bitmap newWaterColors = new Bitmap(biomes.Length, 1);
            Bitmap newFoliageColors = new Bitmap(biomes.Length, 1), newGrassColors = new Bitmap(biomes.Length, 1);

            // asume java and bedrock use the same tint for plains
            {
                var baseColor = Dev(colors["minecraft:grass_block"].colors[plainsIndex], BEDROCK_PLAINS_GRASS_TINT);
                for(int i = 0; i < biomes.Length; i++) {
                    newGrassColors.SetPixel(i, 0, Dev(colors["minecraft:grass_block"].colors[i], baseColor));
                }

                baseColor = Dev(colors["minecraft:oak_leaves"].colors[plainsIndex], BEDROCK_PLAINS_FOLIAGE_TINT);
                for(int i = 0; i < biomes.Length; i++) {
                    newFoliageColors.SetPixel(i, 0, Dev(colors["minecraft:oak_leaves"].colors[i], baseColor));
                }
            }

            foreach(var f in colors) {
                if(f.Value.colors.Distinct().Count() > 1) {
                    Color fColor = default;
                    if(f.Value.tint == "foliage") {
                        fColor = newFoliageColors.GetPixel(0, 0);
                    } else if(f.Value.tint == "grass") {
                        fColor = newGrassColors.GetPixel(0, 0);
                    } else if(f.Value.tint == "water") {
                        for(int i = 0; i < biomes.Length; i++) {
                            newWaterColors.SetPixel(i, 0, f.Value.colors[i]);
                        }
                        continue;
                    }

                    var c = Dev(f.Value.colors[0], fColor);
                    map[f.Key] = $"{c.R:X2}{c.G:X2}{c.B:X2}";
                }
            }

            createFileFromLines(archive, "__colormap__", map.Select(v => $"{v.Key.simplifyminecraftname()};{v.Value}").ToArray());

            createFileFromLines(archive, "grass.properties", ["format=grid", $"blocks={string.Join(" ", tints.First(t => t.tint == "grass").blocks.Select(b => b.simplifyminecraftname()))}", "source=grass.png"]);
            createFile(archive, "grass.png", ImageToByte2(newGrassColors));

            createFileFromLines(archive, "foliage.properties", ["format=grid", $"blocks={string.Join(" ", tints.First(t => t.tint == "foliage").blocks.Select(b => b.simplifyminecraftname()))}", "source=foliage.png"]);
            createFile(archive, "foliage.png", ImageToByte2(newFoliageColors));

            createFileFromLines(archive, "water.properties", ["format=grid", $"blocks={string.Join(" ", tints.First(t => t.tint == "water").blocks.Select(b => b.simplifyminecraftname()))}", "source=water.png"]);
            createFile(archive, "water.png", ImageToByte2(newWaterColors));


            Color Dev(Color c1, Color c2) => Color.FromArgb((int)(c1.R / (double)c2.R * 255), (int)(c1.G / (double)c2.G * 255), (int)(c1.B / (double)c2.B * 255));
            Color Mult(Color c1, Color c2) => Color.FromArgb((int)(c1.R * (double)c2.R / 255), (int)(c1.G * (double)c2.G / 255), (int)(c1.B * (double)c2.B / 255));

            IEnumerable<(string block, string tint, int biome, Color color)> ReadBiomeInGameMap() {
                int bi = 0;
                for(int i = 0; i < biomeMaps.Length; i++) {
                    var biomemap = biomeMaps[i];

                    for(int cz = 0; cz < 5; cz++) {
                        for(int cx = 0; cx < 5; cx++) {
                            if(bi >= biomes.Length) break;

                            int ti = 0;
                            for(int z = 0; z < 8; z++) {
                                for(int x = 0; x < 8; x++) {
                                    if(ti >= tintedBlocks.Count) break;

                                    if(x % 2 == z % 2) {
                                        var color = biomemap.GetPixel(8 + cx * 24 + x, 8 + cz * 24 + z);

                                        var ttint = tints.FirstOrDefault(d => d.blocks.Contains(tintedBlocks[ti]));
                                        if(ttint != default) yield return (tintedBlocks[ti], tints.First(d => d.blocks.Contains(tintedBlocks[ti])).tint, bi, color);

                                        ti++;
                                    }
                                }
                            }

                            bi++;
                        }
                    }
                }
            }

        }









        static Dictionary<string, string> ReadIngameMap(Bitmap bitmap, string[] blocks) {
            Dictionary<string, string> map = new Dictionary<string, string>();

            string airColor = "";
            int i = 0;
            for(int z = 8; z < 128 - 8; z++) {
                for(int x = 8; x < 128 - 8; x++) {
                    if(i >= blocks.Length) break;
                    if(z % 2 == x % 2) {
                        var c = bitmap.GetPixel(x, z);
                        string hexcolor = $"{c.R:X2}{c.G:X2}{c.B:X2}";
                        map[blocks[i]] = hexcolor;

                        if(blocks[i] == "minecraft:air") {
                            airColor = hexcolor;
                        }

                        i++;
                    }
                }
            }
            map = map.Where((a) => a.Value != airColor).ToDictionary();

            return map;
        }


        static void createFile(ZipArchive archive, string name, byte[] content) {
            using var w = archive.CreateEntry(name, CompressionLevel.NoCompression).Open();
            w.Write(content, 0, content.Length);
        }
        static void createFileFromLines(ZipArchive archive, string name, string[] lines) {
            createFile(archive, name, Encoding.UTF8.GetBytes(string.Join(Environment.NewLine, lines)));
        }
        static byte[] ImageToByte2(Image img) {
            using var stream = new MemoryStream();
            img.Save(stream, ImageFormat.Png);
            return stream.ToArray();
        }
    }
}
